#include <cmath>
#include <vector>
#include <tuple>
#include "../catch.hpp"
#include "../../matslise/matslise.h"
#include "../../matslise/liouville.h"
#include "../../matslise/util/constants.h"


using namespace matslise;
using namespace std;
using namespace Eigen;

// https://doi.org/10.17512/jamcm.2016.2.14

TEST_CASE("Example 1: p=1, q=0, w=(1+x)^-2", "[matslise][sturm-liouville]") {
    SturmLiouville<double> sl([](double) -> double { return 1; },
                              [](double) -> double { return 0; },
                              [](double x) { return 1 / (1 + x) / (1 + x); },
                              {0., 1.}, 1e-8);

    Y<> dirichlet = Y<>::Dirichlet();

    int i = 0;
    double f = constants<double>::PI / std::log(2);
    f *= f;
    for (auto &iE: sl.eigenvaluesByIndex(0, 20, dirichlet, dirichlet)) {
        REQUIRE(iE.first == i);
        double exact = 0.25 + f * (i + 1) * (i + 1);

        REQUIRE(Approx(exact).epsilon(1e-6) == iE.second);

        ++i;
    }
    REQUIRE(i == 20);
}

TEST_CASE("Example 2: p=(1+x)², q=x²-2, w=exp(x)", "[matslise][sturm-liouville]") {
    // The values in the article are not accurate. This true values are from Matslise 2.0.

    SturmLiouville<double> sl([](double x) { return (1 + x) * (1 + x); },
                              [](double x) { return x * x - 2; },
                              [](double x) { return std::exp(x); },
                              {0., 1.}, 1e-8);

    Y<> dirichlet = Y<>::Dirichlet();
    Y<> neumann = Y<>::Neumann();

    std::vector<double> exact
            {{
                     1.1704927599022, 26.8633676464100, 78.5490452641401, 156.0801562248233, 259.4554762109302,
                     388.6747906007730, 543.7380371293273, 724.6451922822132, 931.3962455677519, 1163.9911917274574,
                     1422.4300278884762
             }};
    int i = 0;
    for (auto &iE: sl.eigenvaluesByIndex(0, (int) exact.size(), dirichlet, neumann)) {
        REQUIRE(iE.first == i);

        REQUIRE(Approx(exact[i]).epsilon(1e-6) == iE.second);

        ++i;
    }
    REQUIRE(i == exact.size());
}

TEST_CASE("Example 3: p=2+sin(2πx), q=-10, w=1+sqrt(x)", "[matslise][sturm-liouville]") {
    // The values in the article are not accurate. These true values are from Matslise 2.0.
    // The stated boundary conditions are not the same as used in table 5
    // β_1 = 10, β_2 = 1

    SturmLiouville<double> sl([](double x) { return 2 + sin(2 * constants<double>::PI * x); },
                              [](double) -> double { return -10; },
                              [](double x) { return 1 + std::sqrt(x); },
                              {0., 1.}, 1e-8);

    Y<> dirichlet = Y<>::Dirichlet();
    Y<> right;
    right.y() << 2, -10;
    // a z + b p z' = 0, a = 10, b = 1
    // z_r = b p = 2
    // z_r' = -a = -10

    std::vector<double> exact
            {{
                     2.8978512448497, 24.0804524555819, 66.9259933904942, 130.2115116461903, 214.2598167805116,
                     319.2224520213227, 445.1429828280686, 592.0396118279557, 759.9206127332327, 948.7900946287176,
                     1158.6502115312053
             }};
    {
        int i = 0;
        for (auto &iE: sl.eigenvaluesByIndex(0, (int) exact.size(), dirichlet, right)) {
            REQUIRE(iE.first == i);

            REQUIRE(Approx(exact[i]).epsilon(1e-6) == iE.second);

            ++i;
        }

        REQUIRE(i == exact.size());
    }

    ArrayXXd eigenfunctions(101, 3);
    eigenfunctions.col(0)
            << 0.00000000000000, 0.03082848005114, 0.06071459562044, 0.08969950696523, 0.11782390161269, 0.14512773070966, 0.17164999148351, 0.19742856021566, 0.22250007005784, 0.24689982669511, 0.27066175512050, 0.29381837149433, 0.31640077486994, 0.33843865435149, 0.35996030796067, 0.38099267011329, 0.40156134514205, 0.42169064475413, 0.44140362768975, 0.46072214015882, 0.47966685588671, 0.49825731480411, 0.51651195957759, 0.53444816930300, 0.55208228977800, 0.56942965983799, 0.58650463328449, 0.60332059596051, 0.61988997753475, 0.63622425754949, 0.65233396526539, 0.66822867280290, 0.68391698103513, 0.69940649763169, 0.71470380658858, 0.72981442850645, 0.74474277080021, 0.75949206693844, 0.77406430372437, 0.78846013554422, 0.80267878442917, 0.81671792470943, 0.83057355099342, 0.84423982819246, 0.85770892234848, 0.87097081112970, 0.88401307306349, 0.89682065491183, 0.90937561710438, 0.92165685788104, 0.93363981782232, 0.94529616783585, 0.95659348550352, 0.96749492706459, 0.97795890530165, 0.98793878728051, 0.99738263031088, 1.00623297961868, 1.01442675692919, 1.02189527518253, 1.02856442045954, 1.03435504714646, 1.03918363536139, 1.04296325933293, 1.04560491013292, 1.04701920418382, 1.04711848875030, 1.04581932628952, 1.04304530139597, 1.03873004926124, 1.03282035743306, 1.02527914981063, 1.01608813148016, 1.00524986362752, 0.99278905600155, 0.97875291287192, 0.96321044408659, 0.94625074660994, 0.92798036005791, 0.90851988670190, 0.88800012851129, 0.86655802242692, 0.84433264839742, 0.82146154756170, 0.79807752985014, 0.77430608268947, 0.75026342618929, 0.72605520327818, 0.70177575039948, 0.67750786691440, 0.65332298810073, 0.62928166486581, 0.60543425971137, 0.58182177990706, 0.55847678257897, 0.53542430051645, 0.51268275063896, 0.49026479851205, 0.46817816175862, 0.44642634267254, 0.42500928597574;
    eigenfunctions.col(1)
            << 0.00000000000000, 0.04862585936084, 0.09571118539158, 0.14126938867911, 0.18531669209857, 0.22787180569265, 0.26895538281940, 0.30858945124012, 0.34679687525797, 0.38360086792590, 0.41902455810570, 0.45309061093986, 0.48582089750329, 0.51723620824715, 0.54735600452623, 0.57619820261443, 0.60377898494540, 0.63011263375025, 0.65521138273325, 0.67908528289359, 0.70174207904527, 0.72318709399926, 0.74342311774892, 0.76245029934199, 0.78026603943396, 0.79686488180340, 0.81223840237596, 0.82637509455759, 0.83926024992695, 0.85087583359067, 0.86120035377318, 0.87020872550590, 0.87787212861133, 0.88415786056006, 0.88902918522976, 0.89244517913310, 0.89436057732932, 0.89472562201666, 0.89348591774994, 0.89058229837342, 0.88595071214174, 0.87952213316484, 0.87122250930270, 0.86097275900338, 0.84868883237320, 0.83428185503901, 0.81765837714852, 0.79872075417669, 0.77736769105622, 0.75349498647163, 0.72699651982117, 0.69776552912694, 0.66569623368500, 0.63068585992284, 0.59263713195170, 0.55146128853158, 0.50708168411377, 0.45943802139328, 0.40849124412103, 0.35422908923733, 0.29667225409010, 0.23588107535495, 0.17196254005635, 0.10507735649807, 0.03544670768722, -0.03664180005545, -0.11082958202558, -0.18668457673347, -0.26370149179701, -0.34130543207320, -0.41885940349911, -0.49567593667004, -0.57103272710036, -0.64419177428973, -0.71442107190338, -0.78101752562287, -0.84332952542459, -0.90077753233254, -0.95287118196455, -0.99922174366032, -1.03954925081039, -1.07368415507753, -1.10156386785477, -1.12322496341687, -1.13879208443498, -1.14846469922215, -1.15250282744025, -1.15121271223401, -1.14493321460164, -1.13402348072633, -1.11885221689477, -1.09978872039429, -1.07719566870330, -1.05142356527612, -1.02280667457546, -0.99166024502993, -0.95827880861805, -0.92293535248831, -0.88588117518278, -0.84734626275916, -0.80754004485974;
    eigenfunctions.col(2)
            << 0.00000000000000, 0.07423252084125, 0.14594613090621, 0.21500285548781, 0.28128107944018, 0.34467577543364, 0.40509742804869, 0.46247053601027, 0.51673199099876, 0.56782946677015, 0.61571988455848, 0.66036798749603, 0.70174503881726, 0.73982764839919, 0.77459672630872, 0.80603655872286, 0.83413399988494, 0.85887777308019, 0.88025787359771, 0.89826506706406, 0.91289047723598, 0.92412525823008, 0.93196034718209, 0.93638629442789, 0.93739316946130, 0.93497054213577, 0.92910753983743, 0.91979298266466, 0.90701560001171, 0.89076433337732, 0.87102873171239, 0.84779944719111, 0.82106884094392, 0.79083171003000, 0.75708614874995, 0.71983455929294, 0.67908482865749, 0.63485169074058, 0.58715829440017, 0.53603800007321, 0.48153642905384, 0.42371379063408, 0.36264751275194, 0.29843520127284, 0.23119795114824, 0.16108402893140, 0.08827293982890, 0.01297988280764, -0.06453941673686, -0.14398352680558, -0.22499983765065, -0.30717889112319, -0.39004864694336, -0.47306887883468, -0.55562596270312, -0.63702840146854, -0.71650352597846, -0.79319591585729, -0.86616819244949, -0.93440493848419, -0.99682058092826, -1.05227211401133, -1.09957751187038, -1.13754055305366, -1.16498251890371, -1.18078080543125, -1.18391388762651, -1.17351130478548, -1.14890644078135, -1.10968894596262, -1.05575282687519, -0.98733569134839, -0.90504456159984, -0.80986420160448, -0.70314510394863, -0.58657007364652, -0.46210051727306, -0.33190576522973, -0.19828064523258, -0.06355775173520, 0.06997878672463, 0.20017177895807, 0.32505670179588, 0.44291146113932, 0.55228884520460, 0.65203206537844, 0.74127514546722, 0.81943081462449, 0.88616898071086, 0.94138887972048, 0.98518772183827, 1.01782820188136, 1.03970671382026, 1.05132358361114, 1.05325616244632, 1.04613523043613, 1.03062485694511, 1.00740564429009, 0.97716113528027, 0.94056707823288, 0.89828320152065;

    ArrayXd xs;
    xs.setLinSpaced(101, 0, 1);

    {
        int i = 0;
        for (auto &iEf: sl.eigenpairsByIndex(0, (int) eigenfunctions.cols(), dirichlet, right)) {
            INFO("Eigenfunction " << i);
            REQUIRE(get<0>(iEf) == i);

            REQUIRE(Approx(exact[i]).epsilon(1e-6) == get<1>(iEf));

            auto &f = *get<2>(iEf);

            double error = (f(xs).col(0) - eigenfunctions.col(i)).matrix().norm();
            REQUIRE(error < 1e-6);

            ++i;
        }
        REQUIRE(i == eigenfunctions.cols());
    }

}




